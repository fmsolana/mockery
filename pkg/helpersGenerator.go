package pkg

import (
	"context"
	"strings"
)

func (g *Generator) GenerateHelper(ctx context.Context) error {

	g.populateImports(ctx)
	if g.iface == nil {
		return ErrNotSetup
	}

	g.printf(
		"// %s is an autogenerated mock type for the %s type\n", g.mockName(),
		g.iface.Name,
	)

	g.printf("const (\n")
	for _, method := range g.iface.Methods() {
		g.printf("\t%s_%s = \"%s\"\n", g.mockName(), method.Name, method.Name)
	}
	g.printf(")\n")
	for _, method := range g.iface.Methods() {

		ftype := method.Signature
		fname := method.Name

		params := g.genList(ctx, ftype.Params(), ftype.Variadic())
		returns := g.genList(ctx, ftype.Results(), false)

		if len(params.Names) == 0 {
			g.printf("// %s provides a mock function with given fields:\n", fname)
		} else {
			g.printf(
				"// %s provides a mock function with given fields: %s\n", fname,
				strings.Join(params.Names, ", "),
			)
		}
		g.printf(
			"func (_m *%s%s) On%s() *mock.Call {\n", g.mockName(), g.getInstantiatedTypeString(), fname,
		)
		g.printf(
			"\treturn _m.On(%s_%s", g.mockName(), fname,
		)

		for i := 0; i < len(params.Names); i++ {
			g.printf(", mock.Anything")
		}
		g.printf(")\n}\n\n")

		g.printf(
			"func (_m *%s%s) On%sReturn(", g.mockName(), g.getInstantiatedTypeString(), fname,
		)

		for i := 0; i < len(returns.Types); i++ {
			g.printf("_a%v  %s", i, returns.Types[i])
			if i < len(returns.Types)-1 {
				g.printf(", ")
			}

		}

		g.printf(") *mock.Call {\n")
		g.printf(
			"\treturn _m.On%s().Return(", fname,
		)
		for i := 0; i < len(returns.Types); i++ {
			g.printf("_a%v", i)
			if i < len(returns.Types)-1 {
				g.printf(", ")
			}
		}
		g.printf(")\n}\n\n")

	}

	return nil
}
